\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[new]{old-arrows}
\usepackage[all]{xy}
\usepackage{pgfplots}
\usepackage{textcomp}
\usepackage{cancel}

\input{src/macros/macros}
%-------------- template --------------------------------------------------
\input{src/macros/beamerconf}
%----------------------------------------------------------------------------

\begin{document}

\setLecture{5}{Actor model using the Akka framework}


\section{Overview}

\begin{frame}{We are here}

  \vspace*{-2mm}

  \begin{block}{Blocks of sequential code running concurrently and sharing memory:}
    
  \begin{itemize}
    \item What is Scala?
    \item Concurrency in Java and its memory model
    \item Basic concurrency blocks and libraries
    % \item Futures and promises
    \item \textcolor{gray}{\emph{Futures and Promises}}
    \item \textcolor{gray}{\emph{Data-Parallel Collections}}
    \item \textcolor{gray}{\emph{Reactive Programming (Concurrently)}}
    \item \textcolor{gray}{\emph{Software Transactional Memory}}
    \alert{\item Actor model}
  \end{itemize}
  \end{block}
\end{frame}



% \fromBookW[scale=0.7]{32}{98mm}{39mm}
% \fromBook[scale=0.65]{32}{43mm}{98mm}{43mm}{39mm}

% \begin{frame}[fragile]\frametitle{Current thread}
% ~\\[-8mm]
% \begin{columns}
% \begin{column}{0.49\textwidth}
% \begin{lstlisting}
% ...
% \end{lstlisting}
% \end{column}
% \begin{column}{0.49\textwidth}
% ...
% \end{column}
% \end{columns}
% \end{frame}


\begin{frame}\frametitle{What is the actor model}
  \splittwo{0.4}{0.6}{
    \begin{itemize}
      \item \alert{Asynchronous} message exchange between actors
      \item Introduced in \alert{Erlang}\\(we use Akka's actor library)\\~
      \item<2> Active, autonomous, \alert{no shared memory}, no synchronisation
    \end{itemize}
  }{
    \centering
    \includegraphicsframed[scale=1]{src/img/actor.pdf}\\~\\
    \only<2>{\includegraphicsframed[scale=1]{src/img/actor-com.pdf}}
  }
\end{frame}

\begin{frame}[t]\frametitle{What we will see}

  We will use the Akka framework for actors for:
  \begin{itemize}
    \item Declaring \alert{actor classes} and creating \alert{actor instances}
    \item Modelling \alert{actor state} and complex \alert{actor behaviours}
    \item Manipulating the \alert{actor hierarchy} and the \alert{actor lifecycle}
    \item The different message-passing patterns used in \alert{actor communication}
    \item Error recovery using the built-in \alert{actor supervision} mechanism
    \item Using \alert{remote actors} to build concurrent and distributed programs
  \end{itemize}


\end{frame}


\section{Creating actors}

\begin{frame}[t]\frametitle{Core concepts}
  ~\\[-8mm]    
  \splittwo{0.5}{0.5}{
    \begin{exampleblock}{Actor system}
      Hierarchical group of actors with shared configurations, supporting actor creation and logging.
    \end{exampleblock}

    \begin{exampleblock}{Actor class}
      Template that describes the states and behaviour of an actor, used to create instances.
    \end{exampleblock}

    \begin{exampleblock}{Actor instance}
      Entity that exists at runtime, with a state and capable of sending and receiving messages.
    \end{exampleblock}

    \begin{exampleblock}{Message}
      Unit of communication that actors use to communicate. In Akka, any object can be a message.
    \end{exampleblock}
  }{
    \begin{exampleblock}{Mailbox}
      Memory block that is used to buffer messages for a given actor instance.
    \end{exampleblock}

    \begin{exampleblock}{Actor reference}
      Object that allows an object to send messages to a specific actor instance.
    \end{exampleblock}

    \begin{exampleblock}{Dispatcher}
      Component that decides when actors are allowed to process messages. In Akka every dispatcher is also an execution context.
    \end{exampleblock}
  }
\end{frame}

\begin{frame}[fragile]\frametitle{My first actor (class) in Akka}
~\\[-8mm]
\begin{columns}
\begin{column}{0.56\textwidth}
\begin{lstlisting}[emph={Actor, Logging, receive, system,stop}]
import akka.actor._
import akka.event.Logging

class HelloActor(val hello: String) extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case `hello` =>
      log.info(
        s"Received a '$hello'... $hello!")
    case msg     =>
      log.info(
        s"Unexpected message '$msg'")
      context.stop(self)
  }
}
\end{lstlisting}
\end{column}
\begin{column}{0.44\textwidth}
\begin{itemize}
  \item Each \cod{HelloActor} receives messages
  \item ... if it receives its \cod{hello}, it logs and \structure{continues}
  \item ... if it receives something else, it \structure{stops}
  \item \cod{context} -- provides core functions, such as \cod{stop}
  \item \cod{self} -- is the instance's actor reference
\end{itemize}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]\frametitle{Configuring an actor in Akka}
~\\[-6mm]
\begin{columns}
\begin{column}{0.51\textwidth}
\begin{lstlisting}[emph={Actor, Logging, Props}]
object HelloActor { // companion
  // two factory methods below
  def props(hello: String) =
    Props(new HelloActor(hello))
  def propsAlt(hello: String) =
    Props(classOf[HelloActor], hello)
  //def propsAlt2 = Props[HelloActor]
}
\end{lstlisting}
\begin{exampleblock}{Actor configuration}
  \begin{itemize}
      \item actor class
      \item constructor arguments
      \item mailbox
      \item dispatcher
  \end{itemize} 
\end{exampleblock}
\end{column}
\begin{column}{0.49\textwidth}
\begin{block}{Props}
  \begin{itemize}
    \item can receive a block of code,
     used each time a new actor instance is created;
     \item can receive a \cod{Class} object and its arguments
     \item can be sent over the network (should be self-contained)
     \item avoid creating \cod{Props} in the actor class, and use factory methods instead
  \end{itemize}
\end{block}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]\frametitle{My first actor system with an instance}
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem}]
lazy val ourSystem = ActorSystem("OurExampleSystem")
\end{lstlisting}
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf}]
object ActorsCreate extends App {
  val hiActor: ActorRef =
    ourSystem.actorOf(HelloActor.props("ola"), name = "greeter")
  hiActor ! "ola"
  Thread.sleep(1000)
  hiActor ! "hi"
  Thread.sleep(1000)
  ourSystem.shutdown()
}
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]\frametitle{Unhandled messages?}

\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive,unhandled}]
class DeafActor extends Actor {
  val log = Logging(context.system, this)
  def receive = PartialFunction.empty
  override def unhandled(msg: Any) = msg match {
    case msg: String => log.info(s"I do not hear '$msg'")
    case msg         => super.unhandled(msg)
  }
}
\end{lstlisting}
    
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf}]
object ActorsUnhandled extends App {
  val deafActor: ActorRef =
    ourSystem.actorOf(Props[DeafActor], name = "deafy")
  deafActor ! "ola"
  Thread.sleep(1000)
  deafActor ! 1234
  Thread.sleep(1000)
  ourSystem.shutdown()
}
\end{lstlisting}
\end{frame}


\section{Modelling actor behaviour}

\begin{frame}[fragile]\frametitle{My 2nd example in Akka: a (stateful) countdown}
~\\[-6mm]
\begin{columns}
\begin{column}{0.48\textwidth}
\only<2>{\alert{Not allowed in Akka:}}
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive}]
class CountdownActor extends Actor{
  var n = 10
            // never do this
  def receive = if (n > 0) {
    case "count" =>
      log(s"n = $n")
      n -= 1
  } else PartialFunction.empty
}
\end{lstlisting}
\end{column}
\begin{column}{0.52\textwidth}
\pause
\alert{Correct in Akka, using \cod{become}:}
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive,become}]
class CountdownActor extends Actor {
  val log = Logging(context.system, this)
  var n = 10
  def counting: Actor.Receive = {
    case "count" =>
      n -= 1
      log.info(s"n = $n")
      if (n == 0) context.become(done)
  }
  def done = PartialFunction.empty
  def receive = counting
}
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\begin{frame}\frametitle{Actor as a transition system}
  \centering
  \fromBookW[scale=0.7]{278}{126mm}{43mm}
\end{frame}

\begin{frame}[fragile]\frametitle{Running the countdown}

\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive,become}]
object ActorsCountdown extends App {
  val countdown = ourSystem.actorOf(Props[CountdownActor])
  for (i <- 0 until 20) countdown ! "count"
  Thread.sleep(1000)
  ourSystem.shutdown()
}
\end{lstlisting}


\end{frame}


\section{Actor hierarchy and lifecycle}

\begin{frame}[fragile]\frametitle{New example with a parent}

\begin{columns}
\begin{column}{0.47\textwidth}
~\\[1mm]
\centering
\begin{tikzpicture}
  \tikzstyle{nd}=[rectangle,inner sep=4pt,minimum width=10mm,draw=black!60,fill=barcolor!20,very thick]
  \node[nd,draw=none,fill=none,inner sep=1pt](sys){``OurExampleSystem''};
  \node[nd, below=2mm of sys](par){``parent''};
  \node[nd, below=2mm of par,xshift=-12mm](a){child$_1$};
  \node[nd, below=2mm of par,xshift= 12mm](b){child$_2$};
  \draw[<-,thick] (sys)edge(par) (par)edge(a)edge(b); 
\end{tikzpicture}

\pause
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,context,actorOf,receive}]
class ChildActor extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case "sayhi" =>
      val parent = context.parent
      log.info(s"my parent $parent made me say hi!")
  }
  override def postStop() {
    log.info("child stopped!")
  }
}
\end{lstlisting}
\end{column}
\begin{column}{0.54\textwidth}
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive,become,context}]
class ParentActor extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case "create" =>
      context.actorOf(Props[ChildActor])
      log.info(s"created a kid; children = ${context.children}")
    case "sayhi" =>
      log.info("Kids, say hi!")
      for (c <- context.children) c ! "sayhi"
    case "stop" =>
      log.info("parent stopping")
      context.stop(self)
  }
}
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]\frametitle{A more complete view of the hierarchy}
~\\[-6mm]
\begin{columns}
\begin{column}{0.57\textwidth}
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive}]
object ActorsHierarchy extends App {
  val parent = ourSystem.actorOf(Props[ParentActor], "parent")
  parent ! "create"
  parent ! "create"
  Thread.sleep(1000)
  parent ! "sayhi"
  Thread.sleep(1000)
  parent ! "stop"
  Thread.sleep(1000)
  ourSystem.shutdown()
}\end{lstlisting}
\end{column}
\begin{column}{0.41\textwidth}
  \fromBook[scale=0.6]{284}{46mm}{30mm}{46mm}{143mm}
  ~\\
  \splittwo{0.5}{0.5}{
      - ActorSystem
    \\- sys.shutdown
    \\- sys/ctxt.actorOf
    \\
  }{
      - ctxt.stop
    \\- ctxt.become
    \\- ctxt.children
    \\- ctxt.parent
  }
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]\frametitle{A more complete view of the hierarchy}
~\\[-6mm]
\begin{columns}
\begin{column}{0.57\textwidth}
\begin{itemize}
  \item \alert{parent} actor stops $\Rightarrow$ its \alert{children} stop
  \item \structure{user} and \structure{system}:
    \\ are \alert{guardian actors} -- at the top of the hierarchy, to log, restart actors, etc.
  \item hierarchy visible when printing an actor ref, e.g., for the first child;
    \\\code{akka://OurExampleSystem/user/parent/}\texttt{\$}\code{a}
  \item \pause \alert{Next:}
    \cod{ctxt.actorSelection(path)}
\end{itemize}
\end{column}
\begin{column}{0.41\textwidth}
  \fromBook[scale=0.6]{284}{46mm}{30mm}{46mm}{143mm}
  ~\\
  \splittwo{0.5}{0.5}{
      - ActorSystem
    \\- sys.shutdown
    \\- sys/ctxt.actorOf
    \\
  }{
      - ctxt.stop
    \\- ctxt.become
    \\- ctxt.children
    \\- ctxt.parent
  }
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]\frametitle{Discovering actors in the hierarchy}

\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive,Identify,actorSelection}]
class CheckActor extends Actor {
  val log = Logging(context.system, this)
  def receive = {
    case path: String =>
      log.info(s"checking path $path")
      context.actorSelection(path) ! Identify(path)
    case ActorIdentity(path, Some(ref)) =>
      log.info(s"found actor $ref at $path")
    case ActorIdentity(path, None) =>
      log.info(s"could not find an actor at $path")
  }
}
\end{lstlisting}    

\pause
\begin{lstlisting}[emph={Actor, Logging, Props, ourSystem,shutdown,sleep,actorOf,receive,Identify,actorSelection}]
val checker = ourSystem.actorOf(Props[CheckActor], "checker")

checker ! "../*"      // finds the checker and its siblings
checker ! "../../*"   // finds user and system guardians
checker ! "/system/*" // finds internal actors
checker ! "/user/checker2" // logs that no actors were found
\end{lstlisting}
\end{frame}

\section{Message-passing patterns}


\section{Error recovery with actors}


\section{Remote actors}


\end{document}
