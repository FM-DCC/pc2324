\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[new]{old-arrows}
\usepackage[all]{xy}
\usepackage{pgfplots}
\usepackage{textcomp}

\input{src/macros/macros}
%-------------- template --------------------------------------------------
\input{src/macros/beamerconf}
%----------------------------------------------------------------------------

\begin{document}

\setLecture{4}{Basic building blocks of concurrency}


\section{Overview}

\begin{frame}{We are here}

  \vspace*{-2mm}

  \begin{block}{Blocks of sequential code running concurrently and sharing memory:}
    
  \begin{itemize}
    \item What is Scala?
    \item Concurrency in Java and its memory model
    \alert{\item Basic concurrency blocks and libraries}
    \item Futures and promises
    \item Actor model (maybe)
  \end{itemize}
  \end{block}
\end{frame}



% \fromBookW[scale=0.7]{32}{98mm}{39mm}
% \fromBook[scale=0.65]{32}{43mm}{98mm}{43mm}{39mm}

% \begin{frame}[fragile]\frametitle{Current thread}
% ~\\[-8mm]
% \begin{columns}
% \begin{column}{0.49\textwidth}
% \begin{lstlisting}
% ...
% \end{lstlisting}
% \end{column}
% \begin{column}{0.49\textwidth}
% ...
% \end{column}
% \end{columns}
% \end{frame}


\begin{frame}[t]\frametitle{What we will see}

  \begin{itemize}
    \item Tread pools: Executor and ExecutionContext
    \item Non-blocking synchronisation -- compare-and-swap (CAS)
    \item Lazy (concurrent) values
    \item Concurrent collections
    \item Running OS processes
  \end{itemize}


\end{frame}

\section{Existing thread pools in Scala}


\begin{frame}[fragile]\frametitle{Executor interface}
~\\[-8mm]
\begin{columns}
\begin{column}{0.54\textwidth}
\begin{lstlisting}[emph={executor}]
 Executor executor = $\textit{anExecutor}$;
 executor.execute(new RunnableTask1());
 executor.execute(new RunnableTask2());
 ...
\end{lstlisting}
\begin{lstlisting}[emph={executor}]
import scala.concurrent._
import java.util.concurrent.ForkJoinPool

object ExecutorsCreate extends App {
  val executor = new ForkJoinPool
  executor.execute(new Runnable {
    def run() = log("This task is run asynchronously.")
  })
  Thread.sleep(500) // not needed with fork:=false in SBT
}
\end{lstlisting}
\end{column}
\begin{column}{0.49\textwidth}
\begin{itemize}
  \item Executor: can start a new thread, an existing one, or the current one
  \item Abstracts from the management of threads
  \item ExecutorService: API that extends Executor with \code{shutdown}
    \begin{itemize}
      \item \code{executor.shutdown} $\to$ executes all tasks and then stops working threads
      \item \code{executor.awaitTermination(...)} $\to$ force termination if, after a given time, the tasks are not completed
    \end{itemize}
\end{itemize}
\end{column}
\end{columns}
\end{frame}




\begin{frame}\frametitle{Existing thread pools}
... Executor vs Thread
\end{frame}



\section{Lock-free programming}


\section{Lazy values}


\section{Concurrent collections}

\end{document}
