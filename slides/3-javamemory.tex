\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[new]{old-arrows}
\usepackage[all]{xy}
\usepackage{pgfplots}
\usepackage{textcomp}

\input{src/macros/macros}
%-------------- template --------------------------------------------------
\input{src/macros/beamerconf}
%----------------------------------------------------------------------------

\begin{document}

\setLecture{3}{Concurrency in Java and its memory model}


\section{Overview}

\begin{frame}{We are here}

  \vspace*{-2mm}

  \begin{block}{Blocks of sequential code running concurrently and sharing memory:}
    
  \begin{itemize}
    \item What is Scala?
    \alert{\item Concurrency in Java and its memory model}
    \item Basic concurrency blocks and libraries
    \item Futures and promises
    \item Actor model (maybe)
  \end{itemize}
  \end{block}
\end{frame}


\begin{frame}\frametitle{Traditional concurrency}
  \splittwo{0.49}{0.49}{
  \begin{block}{Synchronisation}
    - Coordination of multiple executions in a concurrent system
    \\- Mechanisms to \structure{order} concurrent executions
    \\- Mechanisms to \structure{exchange} information
  \end{block}
  }{
  \begin{block}{Exchanging information}
    - \alert{Concurrent programs: shared memory communication}
    \\- Distributed programs: message passing communication
    
  \end{block}
  }
\end{frame}


\begin{frame}\frametitle{Processes and threads}\centering
  \splittwo{0.46}{0.52}{
    % \fromBookW[scale=0.7]{32}{98mm}{39mm}
    \fromBook[scale=0.65]{32}{43mm}{98mm}{43mm}{39mm}
  }{
    ~\\[4mm]
    Starting a new JVM instance always creates \alert{only one} process.
    \\[4mm]
    In that process, \alert{multiple threads} can run simultaneously.
    \\[4mm]
    Unlike runtimes (e.g. Python), the JVM:
    \\~~does not implement its custom threads,
    \\~~maps each \structure{Java thread} to an \structure{OS thread}
  }
\end{frame}


\section{Managing threads}

\begin{frame}[fragile]\frametitle{Current thread}
~\\[-8mm]
\begin{columns}
\begin{column}{0.49\textwidth}
\begin{lstlisting}
object ThreadsMain extends App {
  val t: Thread = Thread.currentThread
  val name = t.getName
  println(s"I am the thread \Â§name")
}
\end{lstlisting}
\end{column}
\begin{column}{0.49\textwidth}
Using SBT, this prints:
\\\code{[info] I am the thread sbt-bg-threads-1}
\\[4mm]
In SBT do ``\code{set fork := true}''
\\
It will then it prints:
\\\code{[info] I am the thread main}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]\frametitle{Creating threads}
~\\[-8mm]
\begin{columns}
\begin{column}{0.49\textwidth}
\begin{lstlisting}[emph={start,join,run}]
object ThreadsCreation extends App {
  class MyThread extends Thread {
    override def run(): Unit = {
      println("New thread running.")
    }
  } 
  val t = new MyThread
  t.start()
  t.join()
  println("New thread joined.")
}
\end{lstlisting}
\end{column}
\begin{column}{0.49\textwidth}
\alert{\code{start}} eventually causes
\\\alert{\code{run}} to execute in a new thread;
\\[4mm]
the OS decides when;
\\[4mm]
\alert{\code{join}} puts the main thread in a \structure{waiting state}, and allows the OS to re-assign the processor.
% \\[4mm]
\end{column}
\end{columns}
\end{frame}

\begin{frame}%\frametitle{title}
  \fromBookW{35}{32mm}{126mm}
\end{frame}


\begin{frame}[fragile]\frametitle{Simpler thread creation}
~\\[-8mm]
\begin{columns}
\begin{column}{0.49\textwidth}
\begin{lstlisting}[emph={thread,run,start}]
def thread(body: =>Unit): Thread = {
  val t = new Thread {
    override def run() = body
  }
  t.start()
  t
}
\end{lstlisting}
\end{column}
\begin{column}{0.49\textwidth}
\pause
\structure{Using the \code{thread} function}
\begin{lstlisting}[emph={sleep,log,thread,join}]
object ThreadsSleep extends App {
  val t = thread {
    Thread.sleep(1000)
    log("New thread running.")
    Thread.sleep(1000)
    log("Still running.")
    Thread.sleep(1000)
    log("Completed.")
  }
  t.join()
  log("New thread joined.")
}
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]\frametitle{Nondeterministic thread execution}
    ...
\end{frame}


\section{Atomic Execution}
\begin{frame}\frametitle{...}
\end{frame}


\section{Reordering}
\begin{frame}\frametitle{...}
\end{frame}


\section{Locks and synchronization}
\begin{frame}\frametitle{...}
\end{frame}


\section{Deadlocks}
\begin{frame}\frametitle{...}
\end{frame}


\section{Guarded blocks}
\begin{frame}\frametitle{...}
\end{frame}


\section{Interrupting threads}
\begin{frame}\frametitle{...}
\end{frame}


\section{Volatile variables}
\begin{frame}\frametitle{...}
\end{frame}


\section{The Java Memory Model}
\begin{frame}\frametitle{...}
\end{frame}


\section{Immutable objects and final fields}
\begin{frame}\frametitle{...}
\end{frame}


% \begin{frame}[fragile]\frametitle{Package objects}
% ~\\[-8mm]
% \begin{columns}
% \begin{column}{0.56\textwidth}
% \begin{lstlisting}
% package cp
% package object practical {
%   def log(msg: String): Unit =
%     println(s"${Thread.currentThread.getName}: $msg")
% }
% \end{lstlisting}
% \end{column}
% \begin{column}{0.42\textwidth}
% The \texttt{log} function is used throughout these lessons
% \end{column}
% \end{columns}
% \end{frame}


\end{document}
